# ============================================
# GETTGI BACKEND - VARIABLES D'ENVIRONNEMENT
# ============================================
# Copiez ce fichier vers .env et modifiez les valeurs selon votre environnement
# cp env.example .env

# ============================================
# BASE DE DONNÉES POSTGRESQL
# ============================================
# Variables pour le conteneur PostgreSQL (docker-compose)
POSTGRES_DB=GettGi
POSTGRES_USER=postgres
POSTGRES_PASSWORD=root
POSTGRES_PORT=5432

# URL de connexion à la base de données PostgreSQL (Spring Boot)
# Format: jdbc:postgresql://host:port/database
# Pour Docker: jdbc:postgresql://postgres:5432/GettGi
# Pour local: jdbc:postgresql://localhost:5432/GettGi
SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/GettGi

# Nom d'utilisateur de la base de données
SPRING_DATASOURCE_USERNAME=postgres

# Mot de passe de la base de données
SPRING_DATASOURCE_PASSWORD=root

# Configuration Hibernate/JPA
# ?? NOTE: Cette variable n'est plus utilisée directement
# La valeur de ddl-auto est maintenant gérée par les profils Spring (dev/prod)
# En dev: ddl-auto=update (défini dans le profil dev)
# En prod: ddl-auto=validate (défini dans le profil prod)
# Valeurs possibles: none, validate, update, create, create-drop
# SPRING_JPA_HIBERNATE_DDL_AUTO=create-drop

# Timezone pour les dates (format: UTC, Europe/Paris, etc.)
SPRING_JPA_PROPERTIES_HIBERNATE_JDBC_TIME_ZONE=UTC

# ============================================
# SERVEUR SPRING BOOT
# ============================================
# Port sur lequel le serveur Spring Boot écoute
SERVER_PORT=2000

# ============================================
# PROFILS SPRING BOOT
# ============================================
# Profil Spring actif (dev, prod)
# En développement, utilisez 'dev' pour activer les fonctionnalités de debug
#   - ddl-auto: update (mise à jour automatique du schéma)
#   - show-sql: true (affichage des requêtes SQL dans les logs)
#   - format_sql: true (formatage des requêtes SQL)
# En production, utilisez 'prod' pour la sécurité maximale
#   - ddl-auto: validate (validation uniquement, pas de modification)
#   - show-sql: false (masquage des requêtes SQL)
#   - format_sql: false
SPRING_PROFILES_ACTIVE=dev

# ============================================
# SÉCURITÉ - CORS & WEBSOCKET
# ============================================
# Origines autorisées pour CORS (liste avec indices)
# Format: http://domain:port ou http://domain:*
APP_SECURITY_CORS_ALLOWED_ORIGINS_0=http://localhost:*
APP_SECURITY_CORS_ALLOWED_ORIGINS_1=http://127.0.0.1:*
APP_SECURITY_CORS_ALLOWED_ORIGINS_2=null

# Origines autorisées pour WebSocket (liste avec indices)
APP_SECURITY_WEBSOCKET_ALLOWED_ORIGINS_0=http://localhost:*
APP_SECURITY_WEBSOCKET_ALLOWED_ORIGINS_1=http://127.0.0.1:*
APP_SECURITY_WEBSOCKET_ALLOWED_ORIGINS_2=null

# ============================================
# JWT (JSON WEB TOKEN)
# ============================================
# Clé secrète BASE64 (256+ bits minimum) pour signer les tokens JWT
# Générez une clé sécurisée avec: openssl rand -base64 32
# ?? IMPORTANT: Changez cette valeur en production !
JWT_SECRET=c2VjdXJlLXNlY3JldC1rZXktMzJieXRlcy0xMjM0NTY3OA==

# Durée de validité du token JWT en millisecondes
# Exemple: 900000 = 15 minutes, 3600000 = 1 heure
JWT_EXPIRATION_TIME=900000

# Émetteur du token JWT
JWT_ISSUER=gettgi-mvp

# ============================================
# REDIS
# ============================================
# Host Redis
# Pour Docker: redis
# Pour local: localhost
REDIS_HOST=localhost

# Port Redis (par défaut 6379)
REDIS_PORT=6379

# Mot de passe Redis (optionnel, laissez vide si non authentifié)
# ?? Recommandé en production !
REDIS_PASSWORD=

# Timeout de connexion Redis en millisecondes
REDIS_TIMEOUT=2000ms

# ============================================
# PUSH NOTIFICATIONS (FCM - Firebase Cloud Messaging)
# ============================================
# Active les notifications push FCM
PUSH_FCM_ENABLED=false

# Mode test pour FCM (ne pas envoyer de vraies notifications)
PUSH_FCM_DRY_RUN=false

# Chemin vers le fichier de credentials JSON de Firebase
# Exemple: /app/config/firebase-credentials.json
PUSH_FCM_CREDENTIALS_PATH=

# ============================================
# TÉLÉMÉTRIE - MONITORING HORS LIGNE
# ============================================
# Durée après laquelle un device est considéré hors ligne
# Format ISO-8601 (ex: PT5M = 5 minutes, PT1H = 1 heure)
TELEMETRY_OFFLINE_THRESHOLD=PT5M

# Intervalle de vérification des devices hors ligne
# Format ISO-8601 (ex: PT1M = 1 minute)
TELEMETRY_OFFLINE_CHECK_INTERVAL=PT1M

# ============================================
# TÉLÉMÉTRIE - SEUILS D'ALERTES
# ============================================
# Seuil de pression pour détecter une manipulation du collier (0.0 - 1.0)
TELEMETRY_PRESSURE_TAMPERING_THRESHOLD=0.6

# Seuil de pression pour détecter une coupure du collier (0.0 - 1.0)
TELEMETRY_PRESSURE_CUT_THRESHOLD=0.2

# Seuil de vitesse suspecte en mètres par seconde (m/s)
# Exemple: 18.0 m/s = ~64.8 km/h
TELEMETRY_SPEED_SUSPECT_THRESHOLD_MPS=18.0

# Seuil de batterie faible en pourcentage (0-100)
TELEMETRY_BATTERY_LOW_THRESHOLD=20

# Seuil de récupération de batterie en pourcentage (0-100)
# L'alerte batterie faible est résolue quand la batterie dépasse ce seuil
TELEMETRY_BATTERY_RECOVERY_THRESHOLD=25

# ============================================
# TÉLÉMÉTRIE - CONFIGURATION MQTT
# ============================================
# URL du broker MQTT
# Format: tcp://hostname:port ou ssl://hostname:port
TELEMETRY_MQTT_BROKER=tcp://localhost:1883

# Identifiant du client MQTT
TELEMETRY_MQTT_CLIENT=mvp-telemetry-ingestor

# Nom d'utilisateur MQTT (optionnel, laissez vide si non authentifié)
TELEMETRY_MQTT_USERNAME=

# Mot de passe MQTT (optionnel, laissez vide si non authentifié)
TELEMETRY_MQTT_PASSWORD=

# Topic MQTT à écouter (supporte les wildcards MQTT: +, #)
# Exemple: collars/+/telemetry écoute tous les topics collars/{device_id}/telemetry
TELEMETRY_MQTT_TOPIC=collars/+/telemetry

# Niveau de qualité de service MQTT (0, 1 ou 2)
# 0 = At most once (fire and forget)
# 1 = At least once (acknowledged delivery)
# 2 = Exactly once (assured delivery)
TELEMETRY_MQTT_QOS=1

# Timeout pour les acknowledgements MQTT en millisecondes
TELEMETRY_MQTT_COMPLETION_TIMEOUT_MS=5000

# Démarrer automatiquement le client MQTT au démarrage de l'application
TELEMETRY_MQTT_AUTO_STARTUP=true

# ============================================
# TÉLÉMÉTRIE - PERSISTANCE
# ============================================
# Intervalle de flush des données de télémétrie en base
# Format ISO-8601 (ex: PT30S = 30 secondes, PT1M = 1 minute)
TELEMETRY_PERSISTENCE_FLUSH_INTERVAL=PT30S

# Nombre maximum d'entrées en mémoire avant flush forcé
TELEMETRY_PERSISTENCE_MAX_ENTRIES=5000
